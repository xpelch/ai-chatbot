---
description: Use this rule to enforce best coding practices for the project.
alwaysApply: false
---
## 0) Deliverables format (mandatory)

* Deliver **complete, runnable code** (no snippets).
* Minimal structure:

  1. **Directory tree**
  2. **Full files** (one block per file)
  3. **Commands** to run
* **No “what do you prefer?”** questions — pick defaults, document them in 1–2 lines.

---

## 1) Non-negotiable principles

* **KISS**: ≤ 50 lines per function, descriptive names, one concern each.
* **DRY**: duplication ≥ 3 → extract.
* **SOLID**: apply SRP (one reason to change) and DIP (use interfaces for API adapters).
* **Separation of Concerns**:

  * `/api` → request/response handling
  * `/lib` → domain logic
  * `/features/*` → UI + hooks
* **YAGNI**: implement only needed features.
* **Boy-Scout**: leave touched code cleaner.

---

## 2) Default architecture (Next.js)

```
/src
  /app
    /api          # Next.js API routes (OpenAI, wallet endpoints)
    /[feature]    # Route groups per feature (chat, wallet, profile)
/src/features
  /chat
    /components   # UI: Bubble, Composer, TypingIndicator
    /hooks        # useChatStream, useMessages
    /api          # typed clients (fetchAiStream, fetchAiReply)
    /types.ts
  /wallet
    /components
    /hooks
    /api
  /common
    /components   # GlassCard, HeaderBar, etc.
    /utils
```

* **Domain logic** lives in `/lib` (parsing, validation, formatting).
* **No business logic inside UI components**.

---

## 3) Readability & style

* Functions: **verbObject** (`sendPrompt`, `parseResponse`).
* State vars: **nounContext** (`chatMessages`, `walletBalance`).
* Avoid magic strings → export constants.
* Comments explain **why**, not **what**.
* Components: **dumb** = pure render; **smart** = hooks/state.

---

## 4) Errors, logs, observability

* Fail fast: validate input schema (`zod` or `yup`) at API/UI boundaries.
* Structured logs: `{ traceId, op, walletAddr }`.
* Never log private keys/seed phrases.
* `/api/health` endpoint → returns `{ ok: true, model, env }`.

---

## 5) Security

* All API inputs validated.
* Wallet auth: via Privy or wagmi, never trust client-side only.
* Secrets: via `.env.local` + Vercel secrets (never in repo).
* CORS: locked to allowed origins.
* CSP + HTTPS enforced.

---

## 6) Data

* No DB → keep state in client or small KV (Redis/Upstash).
* If DB added later: migrations versioned with Prisma.
* APIs: backward-compatible JSON.

---

## 7) Tests

* **Unit**: `/lib` functions (stream parser, math utils).
* **Integration**: API routes with mocked OpenAI.
* **E2E**: Playwright to check “connect wallet → send prompt → stream reply”.
* CI: `lint → build → test` mandatory.

---

## 8) Performance

* Streaming is default for AI.
* Timeout watchdog per stream call (abort if > 20s silence).
* P95 chat latency < 1s for first token.

---

## 9) Git / CI / CD

* Conventional commits.
* PR ≤ 300 LOC.
* Pipelines: `lint → build → test → scan → deploy`.
* Rollback: redeploy previous Vercel build.

---

## 10) Generation rules

* Group by feature; no useless micro-files.
* Always include types + error handling.
* React: strict TypeScript, functional components.
* No commented-out/dead code.
* No business logic in `/app/api` handlers — delegate to `/lib`.

---

## 11) Preferred templates

### Next.js API Route (streaming OpenAI)

```ts
// src/app/api/ai/route.ts
import { NextRequest } from "next/server";
import { fetchStream } from "@/lib/openai";

export async function POST(req: NextRequest) {
  const { prompt } = await req.json();
  if (!prompt || typeof prompt !== "string") {
    return Response.json({ error: "Invalid prompt" }, { status: 400 });
  }
  return fetchStream(prompt);
}
```

### Chat Hook

```ts
// src/features/chat/hooks/useChatStream.ts
import { useState } from "react";
import { fetchAiStream } from "../api/client";

export function useChatStream() {
  const [messages, setMessages] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);

  async function send(prompt: string) {
    setLoading(true);
    let acc = "";
    await fetchAiStream(prompt, (chunk) => {
      acc += chunk;
      setMessages((prev) => [...prev.slice(0, -1), acc]);
    });
    setLoading(false);
  }

  return { messages, loading, send };
}
```

### Utility function (stream)

```ts
// src/features/chat/api/client.ts
export async function fetchAiStream(
  prompt: string,
  onChunk: (t: string) => void,
  timeout = 20000
) {
  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), timeout);
  const res = await fetch("/api/ai?stream=1", {
    method: "POST",
    body: JSON.stringify({ prompt }),
    headers: { "Content-Type": "application/json" },
    signal: ctrl.signal,
  });
  if (!res.ok || !res.body) throw new Error("Stream failed");

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let done: boolean | undefined, value: Uint8Array | undefined;
  while (!(done = (await reader.read()).done)) {
    value = (await reader.read()).value;
    if (value) onChunk(decoder.decode(value, { stream: true }));
  }
  clearTimeout(timer);
}
```

### Component

```tsx
// src/features/chat/components/Bubble.tsx
export function Bubble({ role, content }: { role: "user"|"assistant"; content: string }) {
  return (
    <div className={`p-3 rounded-2xl ${role==="user" ? "bg-zinc-800 text-white" : "bg-orange-500/20 text-orange-200"}`}>
      {content}
    </div>
  );
}
```

---

## 12) Definition of Done

* [ ] Inputs validated
* [ ] Errors handled + logged
* [ ] Secrets safe in `.env`
* [ ] Streaming replies tested (unit + E2E)
* [ ] Docs: quickstart in `README.md`
* [ ] No duplication, no commented-out code

---